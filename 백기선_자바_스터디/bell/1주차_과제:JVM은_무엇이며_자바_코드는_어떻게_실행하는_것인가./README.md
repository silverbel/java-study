# 목표

자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.

## JVM이란 무엇인가

JVM은 `Java virtual machine`을 줄인 것으로 자바를 실행하기 위한 가상 컴퓨터이다.

자바로 작성된 애플리케이션은 모두 JVM에서만 실행되기 때문에, 자바 애플리케이션을 실행하기 위해서는 JVM이 반드시 필요하다.

> 바이트코드는 기계어가 아니기 때문에 os 바로 실행되지 못한다. JVM은 OS가 바이트코드를 이해할 수 있도록 해석해준다.

## 바이트코드란 무엇인가

- 바이너리 코드

    CPU가 이해하기 위한 기계어는 0과 1로 구성된 바이너리 코드(이진 코드)이다. 기계어가 이진 코드로 이루어졌을 뿐 모든 이진 코드가 기계어인 것은 아니다.

    > **바이너리 코드 != 기계어**

- 바이트 코드

    0과 1로 이루어진 이진 코드이지만 바이너리 코드와 달리 가상머신이 이해할 수 있는 코드이다. 사람에게 친숙한 고급 언어보다는 덜 추상적이지만 기계어보다는 추상적이다.

    고급언어로 작성된 코드를 가상머신이 이해할 수 있도록 컴파일한 것이다. CPU에게 넘어가기 전에 **실시간 번역기 또는 JIT(just-in-time) 컴파일러**에 의해 바이너리 코드로 변환된다.

    > Java는 OS와 직접적으로 대화할 수 없다. 오로지 JVM하고만 상호작용을 한다. 자바는 JVM을 거쳐야만 OS와 대화할 수 있다.
    바이너리 코드와 바이트 코드 둘 다 0과 1로 이루어져 있다. 바이너리 코드는 CPU가 이해할 수 있는 언어, 바이트 코드는 가상 머신이 이해할 수 있는 언어이다.
    그 중에 JVM을 위한 바이트 코드를 “자바 바이트코드”라고 한다.

## JVM의 구성

JVM은 크게 ClassLoader, Runtime Data Area, Excution Engine 3가지로 구성되어 있다.

jvm구성.png![image](https://user-images.githubusercontent.com/20640626/125809526-832d184b-b0e8-41d7-bca3-ab8a79769ced.png)

- Class Loader

    Runtime 시점에 클래스가 로딩이되고, 클래스의 인스턴스가 생성되면 Class Loader를 통해 메모리에 로드된다.

- Runtime Data Area

    JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당받은 메모리 공간을 말한다.

    크게 5가지 영역으로 나눌 수 있다.

    - Method Area

        Class Loader에 의해 적재된 클래스 파일(메타데이터, 상수 런타임 풀, 메서드 등)을 저장한다. 다른 스레드에서도 활용 가능한 공유자원이다.

    - Native Method Stack

        일반적인 메소드를 실행하는 경우 JVM Language Stack에 적재되지만, 네이티브 메소드 스택은 네이티브 라이브러리에 따라 네이티브 코드 명령(C언어와 같이 네이티브 방식으로 작성된 메소드)을 보관한다.

    - PC Register

        Thread가 시작될 때 생성되는 공간으로 Thread마다 하나씩 존재한다. Thread가 어떤 부분을 어떤 명령으로 실행해야 할 지에 대한 기록을 하는 공간이다.현재 실행하고 있는 부분(Java 가상 시스템 명령)의 주소를 가지고 있다.

    - Stack

        프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다. 각 스레드에는 자체 JVM 스택이 있고, 스레드가 생성될 때 동시에 생성된다.각종 형태의 변수나 임시 데이터, 스레드나 메소드의 정보를 저장하고 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.

    - Heap

        new 연산자로 생성된 객체와 배열을 저장하는 메모리 공간이다. 모든 개체, 관련 인스턴스 변수 및 배열은 힙에 저장된다. Method Area에서 클래스 정보를 복사하여 Heap 영역에서 메모리를 할당하여 사용한다.이 메모리는 여러 스레드에 걸쳐 공유된다. 또한, GC의 주 대상이 된다.

- Excution Engine

    클래스 로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치시키면 실행엔진에 의해 실행된다. 자바 바이트 코드를 JVM 내부에서 컴퓨터가 실행할 수 있는 형태인 바이너리 코드로 변경한다.변경하는 방식은 두가지가 있는데, 인터프리터 방식과 JIT 방식이 있다.

    - 바이트코드 → 바이너리코드로 변경하는 방식
        - 인터프리터 방식

            기본 바이트 코드를 실행하는 방법은 인터프리터 방식이 기본이다. 자바 바이트 코드를 명령어 단위로 읽어서 실행하기 때문에 느리다. (한줄씩 해석하고 실행)

        - JIT(just-in-time)

            실행 시점에 인터프리터 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱한다. 전체 컴파일 후 캐싱하고 이후 변경된 부분만 컴파일하고 나머지는 캐시에서 가져다 쓴다.

        > 최초 JVM 이 나왔을 당시에는 Interperter방식(한 줄씩 해석하고 실행)이였기 때문에 속도가 느리다는 단점이 있었지만 JIT complier 방식을 통해 이 점을 보완했습니다. JIT는 ByteCode를 어셈블러 같은 NativeCode로 바꿔서 실행이 빠르지만 역시 변환하는데 비용이 발생합니다. 이 같은 이유 때문에 JVM은 모든 코드를 JIT Compiler 방식으로 실행하지 않고 Interpreter 방식을 사용하다 일정한 기준이 넘어가면 JIT Compiler 방식으로 실행합니다.

    - GC(Garbage Collector)

        참조되지 않는 객체들을 탐색후 삭제하여 heap메모리 재사용하기 위함이다.

        - heap-area 구조 (이미지)

            ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a329b46-a6d3-46ce-b74d-c85209fde3c0/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a329b46-a6d3-46ce-b74d-c85209fde3c0/Untitled.png)

        - minor GC

            eden           → S1 (나머지 삭제)

            eden, S1     → S2 (나머지 삭제)

            S2                → old

        - major GC

            old영역에 있는 모든 객체들을 검사

            참조되지 않은것들을 한번에 삭제.

            minor GC에 비해 시간 오래 걸리고, 실행중 프로세스가 정지.

## JIT 컴파일러란 무엇이며 어떻게 동작하는지

JVM에서 OS로 넘어가기 전에 바이트 코드를 바이너리 코드로 변경해야 한다. 처음에는 인터프리터 방식을 사용하였는데 속도가 느리다보니 이를 해결하기 위해 나온 것이 JIT이다.JIT는 Just In Time의 약자로 JIT 컴파일러는 프로그램이 실행되는 시점에서 컴파일을 시행하는데, 캐시를 보관하여 사용하기 때문에 한 번 컴파일된 코드는 빠른 수행이 가능하다.

인터프리터 방식으로 실행되다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고 이후에는 네이티브 코드로 직접 실행하는 방식이다.

JIT 컴파일러는 실행 엔진(Execution Engine) 내부에서 동작한다.

JVM 구성 요소는 다음과 같다.

1. 클래스 로더 컴파일러가 내부에 만든 .class(바이트 코드)를 런타임 데이터 공간에 **“적재”**한다.
2. 런타임 데이터 공간OS로부터 메모리를 할당받은 공간으로 스택, 힙, 메소드, 네이티브 메소드, PC 레지스터가 있다.
3. GC : 메모리를 정리하는 역할이다.
4. 실행 엔진인터프리터 방식 또는 JIT 컴파일러를 이용하여 데이터 영역에 배치된 바이트 코드를 실행한다.

JIT 컴파일러는 바이트 코드를 바이너리 코드로 변환하는 속도가 느린 인터프리터 방식을 보완하기 위해 나온 것이다.인터프리터 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.

JVM 내부에서는 자바 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환시킨 후 실제 바이트 코드가 실행하는 시점에서 JIT 컴파일러를 통해 기계어로 변환한다.

## 컴파일 하는 방법

- 컴파일이란?

    컴파일러는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 프로그램을 말한다. 기존 문서를 소스 코드 혹은 원시 코드라고 부르고, 출력된 문서를 목적 코드라고 부른다.원시 코드에서 목적 코드로 옮기는 과정을 컴파일이라고 한다.

- 자바 컴파일 과정
    1. 소스 파일 생성한다. (Hello.java)
    2. 자바 컴파일러(javac.exe)를 사용하여 컴파일한다. `$ javac Hello.java`
    3. 컴파일이 정상적으로 완료되면 클래스 파일 생성된다. (Hello.class)
- 실행하는 방법

    자바 인터프리터(java.exe)로 실행한다. `$ java Hello` (실행 시에는 확장자를 붙이지 않는다)

    내부적인 진행순서는 다음과 같다.

    1. 프로그램의 실행에 필요한 클래스(*.class파일)을 로드한다.
    2. 클래스파일을 검사한다. (파일형식, 악성코드 체크)
    3. 지정된 클래스(Hello)에서 `main(String[] args)`을 호출한다.

## JDK와 JRE의 차이

### JDK란?

JDK는 Java Development Kit으로 자바 프로그래밍 시 필요한 컴파일러 등을 포함한다. JDK는 JRE를 포함하며, 개발을 위해 필요한 도구(java, javac 등)를 포함한다.

### JRE란?

JRE는 Java Runtime Enviroment로 컴파일된 자바 프로그램을 실행시킬 수 있는 자바 환경을 말한다. JRE는 JVM의 실행환경을 구현했다고 볼 수 있으며, JVM이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가지고 있다.

![https://yadon079.github.io/assets/img/study/jdkjre.png](https://yadon079.github.io/assets/img/study/jdkjre.png)

---

**Reference**

- [https://ko.wikipedia.org/wiki/](https://ko.wikipedia.org/wiki/)
- [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)
- [https://jdm.kr/blog/188](https://jdm.kr/blog/188)
- [https://jojuim.tistory.com/entry/기본-바이트코드와-바이너리코드](https://jojuim.tistory.com/entry/%EA%B8%B0%EB%B3%B8-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C%EC%99%80-%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC%EC%BD%94%EB%93%9C)
- [https://docs.oracle.com/javase/8/docs/](https://docs.oracle.com/javase/8/docs/)
